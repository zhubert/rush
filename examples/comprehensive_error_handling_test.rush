# Comprehensive Error Handling Test Suite

print("====================================")
print("  COMPREHENSIVE ERROR HANDLING TEST")
print("====================================")

testsPassed = 0
testsTotal = 0

# Helper function to run a test
runTest = fn(testName, testFunc) {
    print("\n--- " + testName + " ---")
    testsTotal = testsTotal + 1
    
    try {
        result = testFunc()
        if (result) {
            print("✓ PASS")
            testsPassed = testsPassed + 1
        } else {
            print("✗ FAIL: Test returned false")
        }
    } catch (error) {
        print("✗ FAIL: Unexpected error -", error.type + ":", error.message)
    }
}

# Test 1: Basic try-catch
basicTryCatch = fn() {
    caught = false
    try {
        throw RuntimeError("test error")
    } catch (error) {
        caught = true
    }
    return caught
}

# Test 2: Type-specific catch
typeSpecificCatch = fn() {
    validationCaught = false
    try {
        throw ValidationError("validation failed")
    } catch (ValidationError error) {
        validationCaught = true
    } catch (error) {
        return false  # Should not reach here
    }
    return validationCaught
}

# Test 3: Multiple catch blocks
multipleCatch = fn() {
    correctCatch = false
    try {
        throw TypeError("wrong type")
    } catch (ValidationError error) {
        return false  # Should not catch ValidationError
    } catch (TypeError error) {
        correctCatch = true  # Should catch TypeError
    } catch (error) {
        return false  # Should not reach generic catch
    }
    return correctCatch
}

# Test 4: Finally block execution
finallyExecution = fn() {
    finallyRan = false
    try {
        throw RuntimeError("error")
    } catch (error) {
        # Exception caught
    } finally {
        finallyRan = true
    }
    return finallyRan
}

# Test 5: Error property access
errorProperties = fn() {
    errorType = ""
    errorMessage = ""
    try {
        throw ValidationError("invalid data")
    } catch (error) {
        errorType = error.type
        errorMessage = error.message
    }
    return (errorType == "ValidationError") && (errorMessage == "invalid data")
}

# Test 6: Stack trace functionality
stackTrace = fn() {
    stackGenerated = false
    
    innerFunc = fn() {
        throw RuntimeError("inner error")
    }
    
    try {
        innerFunc()
    } catch (error) {
        # Check if stack trace contains function name
        stackGenerated = len(error.stack) > 0
    }
    return stackGenerated
}

# Test 7: Array index exception
arrayIndexException = fn() {
    caught = false
    arr = [1, 2, 3]
    try {
        value = arr[10]
    } catch (IndexError error) {
        caught = true
    }
    return caught
}

# Test 8: String index exception
stringIndexException = fn() {
    caught = false
    str = "hello"
    try {
        char = str[20]
    } catch (IndexError error) {
        caught = true
    }
    return caught
}

# Test 9: Pop empty array exception
popEmptyException = fn() {
    caught = false
    emptyArr = []
    try {
        value = pop(emptyArr)
    } catch (IndexError error) {
        caught = true
    }
    return caught
}

# Test 10: Nested try-catch
nestedTryCatch = fn() {
    outerCaught = false
    innerCaught = false
    
    try {
        try {
            throw ValidationError("inner error")
        } catch (TypeError error) {
            return false  # Should not catch TypeError
        }
        # If inner catch doesn't handle it, it propagates to outer
    } catch (ValidationError error) {
        outerCaught = true
    }
    return outerCaught
}

# Test 11: Exception propagation through function calls
exceptionPropagation = fn() {
    caught = false
    
    deepFunc = fn() {
        throw RuntimeError("deep error")
    }
    
    middleFunc = fn() {
        deepFunc()  # Exception should propagate through
    }
    
    try {
        middleFunc()
    } catch (RuntimeError error) {
        caught = true
    }
    return caught
}

# Test 12: All built-in error types
allErrorTypes = fn() {
    errorTypes = ["Error", "ValidationError", "TypeError", "IndexError", "ArgumentError", "RuntimeError"]
    caughtTypes = []
    
    for (i = 0; i < len(errorTypes); i = i + 1) {
        errorType = errorTypes[i]
        try {
            # This is a bit of a hack since we can't dynamically call constructors
            if (errorType == "Error") { throw Error("test") }
            if (errorType == "ValidationError") { throw ValidationError("test") }
            if (errorType == "TypeError") { throw TypeError("test") }
            if (errorType == "IndexError") { throw IndexError("test") }
            if (errorType == "ArgumentError") { throw ArgumentError("test") }
            if (errorType == "RuntimeError") { throw RuntimeError("test") }
        } catch (error) {
            caughtTypes = push(caughtTypes, error.type)
        }
    }
    
    return len(caughtTypes) == len(errorTypes)
}

# Run all tests
runTest("Basic try-catch", basicTryCatch)
runTest("Type-specific catch", typeSpecificCatch)
runTest("Multiple catch blocks", multipleCatch)
runTest("Finally block execution", finallyExecution)
runTest("Error property access", errorProperties)
runTest("Stack trace functionality", stackTrace)
runTest("Array index exception", arrayIndexException)
runTest("String index exception", stringIndexException)
runTest("Pop empty array exception", popEmptyException)
runTest("Nested try-catch", nestedTryCatch)
runTest("Exception propagation", exceptionPropagation)
runTest("All built-in error types", allErrorTypes)

# Test summary
print("\n====================================")
print("           TEST RESULTS")
print("====================================")
print("Tests passed: " + type(testsPassed) + " / " + type(testsTotal))

if (testsPassed == testsTotal) {
    print("🎉 ALL TESTS PASSED!")
} else {
    failedTests = testsTotal - testsPassed
    print("❌ " + type(failedTests) + " test(s) failed")
}

print("====================================")