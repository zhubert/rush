package jit

import (
	"runtime"
	"testing"

	"rush/bytecode"
	"rush/interpreter"
)

func TestARM64JITCompilationIntegration(t *testing.T) {
	// Skip if not on ARM64
	if runtime.GOARCH != "arm64" {
		t.Skip("ARM64 integration tests require ARM64 architecture")
	}

	// Create a simple Rush function in bytecode that adds two integers
	// This represents: func add(a, b) { return a + b }
	instructions := []byte{
		byte(bytecode.OpConstant), 0, 0, // Load first constant (index 0)
		byte(bytecode.OpConstant), 0, 1, // Load second constant (index 1)
		byte(bytecode.OpAdd),             // Add the two values
		byte(bytecode.OpReturn),          // Return the result
	}

	// Create a compiled function
	compiledFn := &interpreter.CompiledFunction{
		Instructions:  instructions,
		NumLocals:     0,
		NumParameters: 2,
	}

	// Test JIT compilation
	compiler := NewJITCompiler()
	fnHash := uint64(12345)

	// Simulate hot function (exceed threshold)
	for i := 0; i < DefaultHotThreshold+1; i++ {
		compiler.RecordExecution(fnHash, 0)
	}

	// Check if compilation is triggered
	if !compiler.ShouldCompile(fnHash) {
		t.Error("Function should be marked for compilation after exceeding threshold")
	}

	// Compile the function
	err := compiler.Compile(compiledFn, fnHash)
	if err != nil {
		t.Fatalf("JIT compilation failed: %v", err)
	}

	// Verify compilation statistics
	stats := compiler.GetStats()
	if stats.CompilationsAttempted == 0 {
		t.Error("No compilation attempts recorded")
	}
	if stats.CompilationsSucceeded == 0 {
		t.Error("No successful compilations recorded")
	}
}

func TestARM64CodeGenerationIntegration(t *testing.T) {
	// Skip if not on ARM64
	if runtime.GOARCH != "arm64" {
		t.Skip("ARM64 integration tests require ARM64 architecture")
	}

	// Create ARM64 code generator
	codegen := NewARM64CodeGen()

	// Simple bytecode: load constant, return
	instructions := bytecode.Instructions{
		byte(bytecode.OpConstant), 0, 0, // Load constant at index 0
		byte(bytecode.OpReturn),          // Return the value
	}

	// Generate ARM64 code
	nativeCode, err := codegen.Generate(instructions)
	if err != nil {
		t.Fatalf("ARM64 code generation failed: %v", err)
	}

	// Validate generated code
	if len(nativeCode) == 0 {
		t.Error("Generated code is empty")
	}

	if len(nativeCode)%4 != 0 {
		t.Error("Generated ARM64 code is not 4-byte aligned")
	}

	// Validate the generated code
	err = ValidateARM64Code(nativeCode)
	if err != nil {
		t.Fatalf("Generated ARM64 code validation failed: %v", err)
	}
}

func TestARM64ExecutionIntegration(t *testing.T) {
	// Skip if not on ARM64
	if runtime.GOARCH != "arm64" {
		t.Skip("ARM64 integration tests require ARM64 architecture")
	}

	// Create a mock compiled code with simple ARM64 instructions
	// This would normally be generated by the code generator
	mockCode := []byte{
		// Function prologue
		0xFF, 0x7F, 0xBF, 0xA9, // STP X29, X30, [SP, #-16]!
		0xFD, 0x03, 0x00, 0x91, // MOV X29, SP
		0xFF, 0x03, 0x01, 0xD1, // SUB SP, SP, #64

		// Simple operation: MOV X0, #42
		0x40, 0x05, 0x80, 0xD2, // MOV X0, #42

		// Function epilogue
		0xFF, 0x03, 0x01, 0x91, // ADD SP, SP, #64
		0xFF, 0x7F, 0xC1, 0xA8, // LDP X29, X30, [SP], #16
		0xC0, 0x03, 0x5F, 0xD6, // RET
	}

	// Create compiled code object
	compiledCode := &CompiledCode{
		NativeCode: mockCode,
		Hash:       12345,
	}

	// Create code cache and make the code executable
	cache := NewCodeCache()
	err := cache.makeExecutable(compiledCode)
	if err != nil {
		// This might fail in test environments without execute permissions
		t.Skipf("Cannot make code executable in test environment: %v", err)
	}

	// Test execution with simple arguments
	args := []interpreter.Value{
		&interpreter.Integer{Value: 10},
		&interpreter.Integer{Value: 20},
	}
	globals := []interpreter.Value{}

	// Note: This test may not actually execute the ARM64 code in a test environment
	// due to security restrictions, but it tests the execution path
	result, err := compiledCode.Execute(args, globals)
	
	// We expect this to fail with deoptimization since we can't actually
	// execute arbitrary ARM64 code in most test environments
	if err == nil {
		t.Log("ARM64 execution succeeded (unexpected in test environment)")
		if result == nil {
			t.Error("Expected non-nil result from ARM64 execution")
		}
	} else {
		t.Logf("ARM64 execution failed as expected in test environment: %v", err)
	}
}

func TestJITCacheIntegration(t *testing.T) {
	// Create code cache
	cache := NewCodeCache()

	// Create mock compiled code
	mockCode := &CompiledCode{
		NativeCode: []byte{0x00, 0x00, 0x80, 0xD2}, // MOV X0, #0
		Hash:       12345,
	}

	// Test adding to cache
	err := cache.Add(12345, mockCode)
	if err != nil {
		t.Fatalf("Failed to add code to cache: %v", err)
	}

	// Test cache hit
	if !cache.Has(12345) {
		t.Error("Cache should contain the added code")
	}

	// Test retrieval
	retrieved := cache.Get(12345)
	if retrieved == nil {
		t.Error("Failed to retrieve code from cache")
	}

	if retrieved.Hash != mockCode.Hash {
		t.Errorf("Retrieved code hash mismatch: got %d, want %d", retrieved.Hash, mockCode.Hash)
	}

	// Test cache statistics
	stats := cache.GetStats()
	if stats.Entries != 1 {
		t.Errorf("Expected 1 cache entry, got %d", stats.Entries)
	}

	if stats.TotalExecutions == 0 {
		t.Error("Expected non-zero total executions after Get()")
	}

	// Test cache removal
	err = cache.Remove(12345)
	if err != nil {
		t.Fatalf("Failed to remove code from cache: %v", err)
	}

	if cache.Has(12345) {
		t.Error("Cache should not contain removed code")
	}
}

func TestJITCompilerLifecycle(t *testing.T) {
	// Create JIT compiler
	compiler := NewJITCompiler()

	// Create a simple function
	compiledFn := &interpreter.CompiledFunction{
		Instructions: []byte{
			byte(bytecode.OpConstant), 0, 0,
			byte(bytecode.OpReturn),
		},
		NumLocals:     0,
		NumParameters: 1,
	}

	fnHash := uint64(54321)

	// Initially should not compile
	if compiler.ShouldCompile(fnHash) {
		t.Error("Cold function should not be marked for compilation")
	}

	// Record executions to make it hot
	for i := 0; i < DefaultHotThreshold+10; i++ {
		compiler.RecordExecution(fnHash, 0)
	}

	// Now should compile
	if !compiler.ShouldCompile(fnHash) {
		t.Error("Hot function should be marked for compilation")
	}

	// Compile the function
	err := compiler.Compile(compiledFn, fnHash)
	if err != nil {
		t.Fatalf("Compilation failed: %v", err)
	}

	// Should not compile again (already compiled)
	if compiler.ShouldCompile(fnHash) {
		t.Error("Already compiled function should not be marked for compilation")
	}

	// Test execution (may fail in test environment)
	args := []interpreter.Value{
		&interpreter.Integer{Value: 42},
	}
	globals := []interpreter.Value{}

	result, err := compiler.Execute(fnHash, args, globals)
	if err != nil {
		// Expected to fail in test environment
		t.Logf("JIT execution failed as expected: %v", err)
	} else {
		t.Logf("JIT execution succeeded: %v", result)
	}

	// Check final statistics
	stats := compiler.GetStats()
	t.Logf("JIT Statistics: %+v", stats)

	if stats.CompilationsAttempted == 0 {
		t.Error("No compilation attempts recorded")
	}
}

func TestExceptionHandlingIntegration(t *testing.T) {
	// Create exception handler
	handler := NewARM64ExceptionHandler()

	// Test installation
	err := handler.Install()
	if err != nil {
		t.Fatalf("Failed to install exception handler: %v", err)
	}
	defer handler.Uninstall()

	// Test safe execution with a function that panics
	_, excInfo, err := handler.SafeExecuteARM64(func() (uint64, error) {
		panic("test panic")
	})

	if err == nil {
		t.Error("Expected error from panicking function")
	}

	if excInfo == nil {
		t.Error("Expected exception info from panicking function")
	} else {
		t.Logf("Exception info: %+v", excInfo)
	}

	// Test safe execution with a normal function
	result, excInfo, err := handler.SafeExecuteARM64(func() (uint64, error) {
		return 42, nil
	})

	if err != nil {
		t.Fatalf("Unexpected error from normal function: %v", err)
	}

	if excInfo != nil {
		t.Error("Expected no exception info from normal function")
	}

	if result != 42 {
		t.Errorf("Expected result 42, got %d", result)
	}
}

func TestFullJITWorkflow(t *testing.T) {
	// Skip if not on ARM64
	if runtime.GOARCH != "arm64" {
		t.Skip("Full JIT workflow test requires ARM64 architecture")
	}

	// This test demonstrates the complete JIT compilation workflow
	// from bytecode to ARM64 execution

	// 1. Create JIT compiler
	compiler := NewJITCompiler()

	// 2. Create a simple Rush function: func test() { return 100 }
	compiledFn := &interpreter.CompiledFunction{
		Instructions: []byte{
			byte(bytecode.OpConstant), 0, 0, // Load constant 100
			byte(bytecode.OpReturn),          // Return the value
		},
		NumLocals:     0,
		NumParameters: 0,
	}

	fnHash := uint64(99999)

	// 3. Simulate function calls to make it hot
	t.Log("Warming up function...")
	for i := 0; i < DefaultHotThreshold+1; i++ {
		compiler.RecordExecution(fnHash, 0)
	}

	// 4. Verify it's marked for compilation
	if !compiler.ShouldCompile(fnHash) {
		t.Fatal("Function should be hot and ready for compilation")
	}

	// 5. Compile to ARM64
	t.Log("Compiling to ARM64...")
	err := compiler.Compile(compiledFn, fnHash)
	if err != nil {
		t.Fatalf("JIT compilation failed: %v", err)
	}

	// 6. Execute the compiled code
	t.Log("Executing ARM64 code...")
	args := []interpreter.Value{}
	globals := []interpreter.Value{}

	result, err := compiler.Execute(fnHash, args, globals)
	if err != nil {
		// This is expected to fail in most test environments
		t.Logf("ARM64 execution failed (expected in test environment): %v", err)
		
		// Verify it's a deoptimization error (fallback to interpreter)
		if !contains(err.Error(), "deoptimizing") && !contains(err.Error(), "execution failed") && !contains(err.Error(), "execution environment validation failed") {
			t.Errorf("Expected deoptimization error, got: %v", err)
		}
	} else {
		t.Logf("ARM64 execution succeeded with result: %v", result)
		
		// If execution succeeded, verify the result
		if result == nil {
			t.Error("Expected non-nil result from ARM64 execution")
		}
	}

	// 7. Check final statistics
	stats := compiler.GetStats()
	t.Logf("Final JIT Statistics:")
	t.Logf("  Compilations Attempted: %d", stats.CompilationsAttempted)
	t.Logf("  Compilations Succeeded: %d", stats.CompilationsSucceeded)
	t.Logf("  Compilations Failed: %d", stats.CompilationsFailed)
	t.Logf("  JIT Hits: %d", stats.JITHits)
	t.Logf("  JIT Misses: %d", stats.JITMisses)
	t.Logf("  Deoptimizations: %d", stats.Deoptimizations)

	// Verify statistics make sense
	if stats.CompilationsAttempted == 0 {
		t.Error("Expected at least one compilation attempt")
	}

	if stats.JITHits == 0 && result != nil {
		t.Error("Expected JIT hits if execution succeeded")
	}

	if stats.Deoptimizations > 0 {
		t.Log("Deoptimizations occurred (expected in test environment)")
	}
}

// Helper function to check if a string contains a substring
func contains(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || 
		(len(s) > len(substr) && 
			(s[:len(substr)] == substr || 
				s[len(s)-len(substr):] == substr || 
				indexOfSubstring(s, substr) >= 0)))
}

func indexOfSubstring(s, substr string) int {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return i
		}
	}
	return -1
}