# Standard library array module
# Provides common array manipulation functions

# Native functions push, pop, and slice are automatically injected by the interpreter

export length = fn(arr) {
  # Use built-in len function
  return len(arr)
}

export map = fn(arr, func) {
  result = []
  i = 0
  while (i < len(arr)) {
    result = push(result, func(arr[i]))
    i = i + 1
  }
  return result
}

export filter = fn(arr, func) {
  result = []
  i = 0
  while (i < len(arr)) {
    if (func(arr[i])) {
      result = push(result, arr[i])
    }
    i = i + 1
  }
  return result
}

export reduce = fn(arr, func, initial) {
  result = initial
  i = 0
  while (i < len(arr)) {
    result = func(result, arr[i])
    i = i + 1
  }
  return result
}

export find = fn(arr, func) {
  i = 0
  while (i < len(arr)) {
    if (func(arr[i])) {
      return arr[i]
    }
    i = i + 1
  }
  return null
}

export index_of = fn(arr, element) {
  i = 0
  while (i < len(arr)) {
    if (arr[i] == element) {
      return i
    }
    i = i + 1
  }
  return -1
}

export includes? = fn(arr, element) {
  return index_of(arr, element) != -1
}

export reverse = fn(arr) {
  result = []
  i = len(arr) - 1
  while (i >= 0) {
    result = push(result, arr[i])
    i = i - 1
  }
  return result
}

export sort = fn(arr) {
  # Simple bubble sort implementation
  result = slice(arr, 0, len(arr))  # Create a copy
  n = len(result)
  i = 0
  while (i < n - 1) {
    j = 0
    while (j < n - i - 1) {
      if (result[j] > result[j + 1]) {
        # Swap elements
        temp = result[j]
        result[j] = result[j + 1]
        result[j + 1] = temp
      }
      j = j + 1
    }
    i = i + 1
  }
  return result
}